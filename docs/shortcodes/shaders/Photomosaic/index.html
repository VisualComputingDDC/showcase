<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Photomosaic # 1. Introduction & Background # Photomosaic is a technique in visual computing that involves creating a larger image by assembling numerous smaller images called tiles. These tiles, often small photographs or images, are carefully chosen to replicate the colors and patterns of specific regions within the larger target image. When viewed from a distance, the tiles blend together to form a cohesive and visually appealing composition. Photomosaic has gained popularity as a creative and artistic way to transform images into stunning collages and visual representations."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Photomosaic # 1. Introduction & Background # Photomosaic is a technique in visual computing that involves creating a larger image by assembling numerous smaller images called tiles. These tiles, often small photographs or images, are carefully chosen to replicate the colors and patterns of specific regions within the larger target image. When viewed from a distance, the tiles blend together to form a cohesive and visually appealing composition. Photomosaic has gained popularity as a creative and artistic way to transform images into stunning collages and visual representations."><meta property="og:type" content="article"><meta property="og:url" content="https://VisualComputingDDC.github.io/showcase/docs/shortcodes/shaders/Photomosaic/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-19T22:45:26-05:00"><title>Photomosaic | Visual Computing 2023-1 - G1 - DDC</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Visual Computing 2023-1 - G1 - DDC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Shortcodes</span><ul><li><a href=/showcase/docs/shortcodes/group-members/>Group Members</a></li><li><input type=checkbox id=section-6d6445ed16f829ce6720abb33c55105e class=toggle checked>
<label for=section-6d6445ed16f829ce6720abb33c55105e class="flex justify-between"><a href=/showcase/docs/shortcodes/shaders/>Shaders</a></label><ul><li><input type=checkbox id=section-2f065ccbcba70d5bdd25eb8a8f238142 class=toggle>
<label for=section-2f065ccbcba70d5bdd25eb8a8f238142 class="flex justify-between"><a role=button>Coloring</a></label><ul><li><a href=/showcase/docs/shortcodes/shaders/Coloring/Brightness-Coloring/>Brightness Coloring</a></li><li><a href=/showcase/docs/shortcodes/shaders/Coloring/Normal-Coloring/>Normal Coloring</a></li></ul></li><li><a href=/showcase/docs/shortcodes/shaders/Image-Processing/>Image Processing</a></li><li><a href=/showcase/docs/shortcodes/shaders/Photomosaic/ class=active>Photomosaic</a></li><li><a href=/showcase/docs/shortcodes/shaders/Post-Effects/>Post Effects</a></li><li><a href=/showcase/docs/shortcodes/shaders/Procedural-Texturing/>Procedural Texturing</a></li><li><a href=/showcase/docs/shortcodes/shaders/Spatial-Coherence/>Spatial Coherence</a></li><li><a href=/showcase/docs/shortcodes/shaders/Texturing/>Texturing</a></li></ul></li><li><input type=checkbox id=section-67f2b433a931c89e2e9c26b761fd42ff class=toggle>
<label for=section-67f2b433a931c89e2e9c26b761fd42ff class="flex justify-between"><a href=/showcase/docs/shortcodes/visual-illusions/>Visual Illusions</a></label><ul><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-3D-terrain-generation-with-perlin-noise/>Academic Report 3 D Terrain Generation With Perlin Noise</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Color-Average/>Academic Report Color Average</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Color-Blind/>Academic Report Color Blind</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Moir%C3%A9-Patterns/>Academic Report Moir√© Patterns</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Spatial-Coherence/>Academic Report Spatial Coherence</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Presentation-Video/>Presentation Video</a></li></ul></li></ul></li></ul><ul><li><a href=/showcase/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Photomosaic</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#photomosaic>Photomosaic</a><ul><li><a href=#1-introduction--background>1. Introduction & Background</a></li><li><a href=#2-code--results>2. Code & results</a></li><li><a href=#3-conclusion>3. Conclusion</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=photomosaic>Photomosaic
<a class=anchor href=#photomosaic>#</a></h1><h2 id=1-introduction--background>1. Introduction & Background
<a class=anchor href=#1-introduction--background>#</a></h2><p>Photomosaic is a technique in visual computing that involves creating a larger image by assembling numerous smaller images called tiles. These tiles, often small photographs or images, are carefully chosen to replicate the colors and patterns of specific regions within the larger target image. When viewed from a distance, the tiles blend together to form a cohesive and visually appealing composition. Photomosaic has gained popularity as a creative and artistic way to transform images into stunning collages and visual representations.</p><p>Photomosaic has been a subject of interest in the field of visual computing, attracting researchers and artists alike. Various studies and research papers have explored different aspects of photomosaic creation, algorithms, and applications. Here are some key areas covered in the literature:</p><p>Tile Selection Algorithms:
One crucial aspect of photomosaic creation is the selection of appropriate tiles to match the target image regions accurately. Several algorithms have been proposed to optimize the tile selection process. These algorithms consider factors such as color similarity, texture, and spatial arrangement to ensure a visually pleasing and coherent result. Research has focused on developing efficient and effective tile selection techniques to improve the quality of photomosaic compositions.</p><p>Image Analysis and Processing:
Photomosaic involves analyzing the target image to identify regions and extract features for tile placement. Image analysis techniques such as color histograms, edge detection, and texture analysis are employed to partition the target image into smaller regions and determine the best matching tiles. Additionally, image processing methods like color correction and blending are applied to enhance the visual quality and seamless integration of tiles.</p><p>Computational Efficiency:
Creating a photomosaic can be computationally intensive, especially for large-scale images with a high number of tiles. Researchers have explored techniques to optimize the computational efficiency of the photomosaic generation process. This includes parallel computing, distributed systems, and algorithmic optimizations to reduce the time and resources required for creating photomosaics.</p><p>Applications and Artistic Expressions:
Photomosaic techniques have found applications in various domains, including art, design, and visual communication. Artists and designers have leveraged photomosaic to create unique visual representations, collages, and illustrations. Moreover, photomosaic has been applied to image compression, image synthesis, and interactive multimedia systems, allowing for novel and creative applications in visual computing.</p><p>By studying the existing literature on photomosaic, researchers and practitioners aim to advance the field by developing new algorithms, refining techniques, and exploring innovative applications. The interdisciplinary nature of photomosaic research brings together computer graphics, image processing, computer vision, and human-computer interaction to create captivating and visually striking compositions from individual tiles.</p><h2 id=2-code--results>2. Code & results
<a class=anchor href=#2-code--results>#</a></h2><p>The code demonstrates how to implement photomosaic using shaders in P5.js. The code utilizes shaders to create a photomosaic by replacing regions of the image with smaller images called tiles.</p><details open><summary>variable declarations</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>img</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tileSize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// Size of each mosaic tile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>colorImages</span> <span style=color:#f92672>=</span> []; <span style=color:#75715e>// Array to store the color images
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>Shader</span>;
</span></span></code></pre></div></div></details><ul><li><p>Variable Declarations:</p><p>Variable Declarations:
img: It stores the target image to be transformed into a photomosaic.
tileSize: It represents the size of each tile in the mosaic.
colorImages: It is an array that holds the color images used as tiles.
Shader: It stores the shader program.</p></li></ul><details open><summary>preload()</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>preload</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Load the image
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/vangogh.webp&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Load the color images
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/amarillo.webp&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/azul_claro.webp&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/azul_oscuro.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/blanco.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/cafe.webp&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/gris.webp&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>6</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/morado.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/naranja.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/negro.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>9</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/rojo.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/rosado.jpg&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>colorImages</span>[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#39;../../../../images/verde.jpg&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li><p>preload()</p><p>preload() Function:
The function loads the target image (principal.jpg) and color images (amarillo.webp, azul_claro.webp, etc.) into the corresponding variables.</p></li></ul><details open><summary>setup()</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Shader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createShader</span>(<span style=color:#a6e22e>vertShader</span>, <span style=color:#a6e22e>fragShader</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Shader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uImage&#39;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Shader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uTileSize&#39;</span>, <span style=color:#a6e22e>tileSize</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Shader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uColorCount&#39;</span>, <span style=color:#a6e22e>colorImages</span>.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>colorImages</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Shader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;uColorImages[&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;]&#39;</span>, <span style=color:#a6e22e>colorImages</span>[<span style=color:#a6e22e>i</span>]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noLoop</span>(); <span style=color:#75715e>// Only draw once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div></details><ul><li><p>setup()</p><p>setup() Function:
The function creates a canvas with the same dimensions as the target image using
createCanvas().
The shader program is created using createShader() and stored in the Shader variable.
Uniform variables in the shader program are set using Shader.setUniform(). These variables include the target image (uImage), tile size (uTileSize), the number of color images (uColorCount), and the color images themselves (uColorImages).
A for loop iterates over the colorImages array to set the uColorImages uniform for each color image.
Finally, noLoop() is called to ensure that the draw() function is executed only once.</p></li></ul><details open><summary>draw()</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>Shader</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li><p>draw()</p><p>draw() Function:
The function applies the Shader program to the canvas using the shader() function, which activates the photomosaic effect.</p></li></ul><details open><summary>vertShader</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>vertShader</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>precision highp float;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>attribute vec3 aPosition;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>varying vec2 vTexCoord;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>void main() {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  vTexCoord = (aPosition.xy + 1.0) / 2.0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  gl_Position = vec4(aPosition, 1.0);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>;
</span></span></code></pre></div></div></details><ul><li><p>vertex shader</p><p>vertShader is responsible for setting the position of each vertex in the mesh.</p></li></ul><details open><summary>fragShader</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fragShader</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>precision highp float;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>varying vec2 vTexCoord;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>uniform sampler2D uImage;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>uniform float uTileSize;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>uniform sampler2D uColorImages[12];
</span></span></span><span style=display:flex><span><span style=color:#e6db74>uniform int uColorCount;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>vec4 getClosestColor(vec4 targetColor) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  float closestDistance = 100000.0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  vec4 closestColor;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  for (int i = 0; i &lt; 12; i++) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    if (i &gt;= uColorCount) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      break;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    vec4 color = texture2D(uColorImages[i], vTexCoord);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    float distance = distance(color.rgb, targetColor.rgb);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    if (distance &lt; closestDistance) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      closestDistance = distance;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      closestColor = color;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  return closestColor;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>void main() {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  vec2 uv = vTexCoord * 2.0 - 1.0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  vec2 tileUV = floor(uv * uTileSize) / uTileSize;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  vec2 tileCenter = tileUV * 2.0 / uTileSize + 1.0 / uTileSize - 1.0;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  vec4 tileColor = texture2D(uImage, tileCenter);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  vec4 mosaicColor = getClosestColor(tileColor);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  gl_FragColor = mosaicColor;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>;
</span></span></code></pre></div></div></details><ul><li><p>fragment shader</p><p>fragShader is the fragment shader that performs the photomosaic effect.
The fragment shader takes the target image and divides it into tiles using the uTileSize uniform. It then calculates the closest color match for each tile by comparing it with the color images (uColorImages). The resulting color is assigned to gl_FragColor, which determines the final color of each fragment in the mosaic.</p><p>In summary, this code uses shaders to create a photomosaic effect by replacing regions of the target image with smaller color images (tiles) based on their closest color match. The resulting image is rendered on a canvas using WebGL.</p></li></ul><iframe id=photomosaic style=width:825px;height:825px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/photomosaic.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h2 id=3-conclusion>3. Conclusion
<a class=anchor href=#3-conclusion>#</a></h2><p>The photomosaic technique in visual computing involves creating a larger image using numerous smaller images called tiles. This technique has attracted interest in the field, leading to research and exploration in various areas. Tile selection algorithms have been developed to optimize the process of selecting tiles that accurately replicate the colors and patterns of the target image. Image analysis and processing techniques are used to partition the target image, extract features, and enhance the visual quality of the photomosaic. Efforts have also been made to improve the computational efficiency of photomosaic generation, considering the resource-intensive nature of the process. Photomosaic techniques find applications in art, design, image compression, and interactive multimedia systems, allowing for creative expressions and innovative uses in visual computing.</p><p>The provided code demonstrates how to implement a photomosaic effect using shaders in P5.js. It utilizes shaders to replace regions of the target image with smaller images (tiles), creating the photomosaic effect. The code loads the target image and color images, sets up the shader program with necessary uniform variables, and applies the shader program to create the photomosaic effect. By combining the techniques presented in the literature with the implementation in the code, it becomes possible to generate captivating and visually striking compositions from individual tiles. This code serves as a practical demonstration of the photomosaic technique and can be further extended and customized to explore different variations and artistic expressions.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/5ba0a1513a3426790b1a5721d2cf1cf54f5cd3df title='Last modified by danvargasgo | June 20, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 20, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#photomosaic>Photomosaic</a><ul><li><a href=#1-introduction--background>1. Introduction & Background</a></li><li><a href=#2-code--results>2. Code & results</a></li><li><a href=#3-conclusion>3. Conclusion</a></li></ul></li></ul></nav></div></aside></main></body></html>