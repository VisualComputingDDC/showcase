<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Procedural Texturing # 1. Introduction & Background # The goal in procedural texturing is to procedurally generate a texture using an algorithm in such a way that the result can be mapped onto a shape as a texture. Procedural texturing requires the use of a frame buffer object which in p5.js is implemented as a p5.Graphics object (Procedural Texturing, 2023).
A framebuffer (frame buffer, or sometimes framestore) is a portion of random-access memory (RAM) containing a bitmap that drives a video display."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Procedural Texturing # 1. Introduction & Background # The goal in procedural texturing is to procedurally generate a texture using an algorithm in such a way that the result can be mapped onto a shape as a texture. Procedural texturing requires the use of a frame buffer object which in p5.js is implemented as a p5.Graphics object (Procedural Texturing, 2023).
A framebuffer (frame buffer, or sometimes framestore) is a portion of random-access memory (RAM) containing a bitmap that drives a video display."><meta property="og:type" content="article"><meta property="og:url" content="https://VisualComputingDDC.github.io/showcase/docs/shortcodes/shaders/Procedural-Texturing/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-19T16:57:03-05:00"><title>Procedural Texturing | Visual Computing 2023-1 - G1 - DDC</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Visual Computing 2023-1 - G1 - DDC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Shortcodes</span><ul><li><a href=/showcase/docs/shortcodes/group-members/>Group Members</a></li><li><input type=checkbox id=section-6d6445ed16f829ce6720abb33c55105e class=toggle checked>
<label for=section-6d6445ed16f829ce6720abb33c55105e class="flex justify-between"><a href=/showcase/docs/shortcodes/shaders/>Shaders</a></label><ul><li><input type=checkbox id=section-2f065ccbcba70d5bdd25eb8a8f238142 class=toggle>
<label for=section-2f065ccbcba70d5bdd25eb8a8f238142 class="flex justify-between"><a role=button>Coloring</a></label><ul><li><a href=/showcase/docs/shortcodes/shaders/Coloring/Brightness-Coloring/>Brightness Coloring</a></li><li><a href=/showcase/docs/shortcodes/shaders/Coloring/Normal-Coloring/>Normal Coloring</a></li></ul></li><li><a href=/showcase/docs/shortcodes/shaders/Image-Processing/>Image Processing</a></li><li><a href=/showcase/docs/shortcodes/shaders/Photomosaic/>Photomosaic</a></li><li><a href=/showcase/docs/shortcodes/shaders/Post-Effects/>Post Effects</a></li><li><a href=/showcase/docs/shortcodes/shaders/Procedural-Texturing/ class=active>Procedural Texturing</a></li><li><a href=/showcase/docs/shortcodes/shaders/Spatial-Coherence/>Spatial Coherence</a></li><li><a href=/showcase/docs/shortcodes/shaders/Texturing/>Texturing</a></li></ul></li><li><input type=checkbox id=section-67f2b433a931c89e2e9c26b761fd42ff class=toggle>
<label for=section-67f2b433a931c89e2e9c26b761fd42ff class="flex justify-between"><a href=/showcase/docs/shortcodes/visual-illusions/>Visual Illusions</a></label><ul><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-3D-terrain-generation-with-perlin-noise/>Academic Report 3 D Terrain Generation With Perlin Noise</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Color-Average/>Academic Report Color Average</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Color-Blind/>Academic Report Color Blind</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Moir%C3%A9-Patterns/>Academic Report Moir√© Patterns</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Academic-Report-Spatial-Coherence/>Academic Report Spatial Coherence</a></li><li><a href=/showcase/docs/shortcodes/visual-illusions/Presentation-Video/>Presentation Video</a></li></ul></li></ul></li></ul><ul><li><a href=/showcase/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Procedural Texturing</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#procedural-texturing>Procedural Texturing</a><ul><li><a href=#1-introduction--background>1. Introduction & Background</a></li><li><a href=#2-code--results>2. Code & results</a></li><li><a href=#3-conclusions--future-work>3. Conclusions & future work</a></li><li><a href=#references>References</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=procedural-texturing>Procedural Texturing
<a class=anchor href=#procedural-texturing>#</a></h1><h2 id=1-introduction--background>1. Introduction & Background
<a class=anchor href=#1-introduction--background>#</a></h2><p>The goal in procedural texturing is to procedurally generate a texture using an algorithm in such a way that the result can be mapped onto a shape as a texture. Procedural texturing requires the use of a frame buffer object which in p5.js is implemented as a p5.Graphics object (Procedural Texturing, 2023).</p><p>A framebuffer (frame buffer, or sometimes framestore) is a portion of random-access memory (RAM) containing a bitmap that drives a video display. It is a memory buffer containing data representing all the pixels in a complete video frame. Modern video cards contain framebuffer circuitry in their cores. This circuitry converts an in-memory bitmap into a video signal that can be displayed on a computer monitor (Framebuffer, n.d.).</p><p>In this exercise, two adapted patterns from the book of shaders (The Book of Shaders: Patterns, n.d.) are mapped as textures onto two different 3D shapes. The first shape is a torus whose level of details can be altered by the user, and the second one is a cube. In both codes, the user can interact with the canva to change the camera direction.</p><p>There have been different approaches and implementations of procedural texturing, for example, for the simulation of the annual ring patterns of solid wood with knots (Procedural texturing of solid wood with knots, 2022) that can be studied in the biology field, simulation of clouds (Simulating clouds with procedural texturing techniques using the GPU, 2012), etc.</p><h2 id=2-code--results>2. Code & results
<a class=anchor href=#2-code--results>#</a></h2><details open><summary>setup()</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>550</span>, <span style=color:#ae81ff>400</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraphics</span>(<span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>detailX</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createSlider</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>detailX</span>.<span style=color:#a6e22e>position</span>(<span style=color:#ae81ff>10</span>, <span style=color:#a6e22e>height</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>detailX</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;width&#39;</span>, <span style=color:#e6db74>&#39;80px&#39;</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>myShader</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>myShader</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>myShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;u_zoom&#39;</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>texture</span>(<span style=color:#a6e22e>pg</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li><p>setup()</p><p>The pg variable is created using the createGraphics() function. It creates a separate graphics buffer with a size of 400 pixels by 400 pixels using the WEBGL renderer. This buffer will be used for rendering textures.</p><p>The textureMode(NORMAL) function sets the texture coordinate mode to NORMAL, which means that the texture coordinates will be normalized between 0 and 1.</p><p>The detailX variable is created using the createSlider() function. It creates a slider UI element with a minimum value of 3, maximum value of 24, and an initial value of 3.</p><p>The pg.shader(myShader) line assigns the custom shader to the pg graphics buffer.</p><p>The myShader.setUniform(&lsquo;u_zoom&rsquo;, 3) line sets the uniform variable &lsquo;u_zoom&rsquo; in the shader to a value of 3. This value is used to control the zoom level in the shader calculations.</p><p>The pg.quad(-1, -1, 1, -1, 1, 1, -1, 1) function call draws a quadrilateral shape in the pg graphics buffer. The provided coordinates (-1, -1), (1, -1), (1, 1), and (-1, 1) represent the four corners of the quad.</p><p>Finally, the texture(pg) function call sets the pg graphics buffer as the texture for subsequent rendering on the canvas.</p></li></ul><p><details open><summary>draw() Program 1</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>33</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>orbitControl</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>torus</span>(<span style=color:#ae81ff>150</span>, <span style=color:#ae81ff>80</span>, <span style=color:#a6e22e>detailX</span>.<span style=color:#a6e22e>value</span>(), <span style=color:#ae81ff>12</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><details open><summary>draw() Program 2</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>33</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>orbitControl</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>box</span>(<span style=color:#ae81ff>300</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details></p><ul><li><p>draw()</p><p>The orbitControl() function enables mouse-based orbit control for the 3D canvas. It allows the user to interactively rotate and zoom the 3D scene by dragging the mouse.</p><p><em>Program 1</em>. The torus(150, 80, detailX.value(), 12) function call draws a torus shape in the 3D canvas. The torus has a major radius of 150, a minor radius of 80, and a number of sides (detail) determined by the value of the detailX slider (obtained using detailX.value()). The last parameter, 12, specifies the number of segments around the torus.</p><p><em>Program 2</em>. The box() function is a built-in p5.js function used to draw a 3D box shape.</p></li></ul><details open><summary>mouseMoved()</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mouseMoved</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>myShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;u_zoom&#39;</span>, <span style=color:#66d9ef>int</span>(<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>mouseX</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>width</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>30</span>)));
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li><p>mouseMoved()</p><p>The line myShader.setUniform(&lsquo;u_zoom&rsquo;, int(map(mouseX, 0, width, 1, 30))) adjusts the value of the uniform variable u_zoom in the shader based on the current x-coordinate of the mouse (mouseX). The map() function is used to map the range of mouseX from the range of 0 to the width of the canvas (width) to a new range of 1 to 30. The resulting value is then converted to an integer (int) and assigned to the u_zoom uniform in the shader. This code adjusts the zoom level of the shader effect based on the horizontal position of the mouse.</p><p>The pg.quad(-1, -1, 1, -1, 1, 1, -1, 1) line draws a quadrilateral shape in the pg graphics buffer. The provided coordinates (-1, -1), (1, -1), (1, 1), and (-1, 1) represent the four corners of the quad. This line is used to redraw the contents of the pg buffer after updating the u_zoom uniform.</p></li></ul><details open><summary>Common in shader1.frag and shader2.frag</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifdef GL_ES
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>precision mediump <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PI 3.14159265358979323846
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>uniform vec2 u_resolution;
</span></span><span style=display:flex><span>uniform <span style=color:#66d9ef>float</span> u_zoom;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vec2 <span style=color:#a6e22e>rotate2D</span> (vec2 _st, <span style=color:#66d9ef>float</span> _angle) {
</span></span><span style=display:flex><span>  _st <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>  _st <span style=color:#f92672>=</span> <span style=color:#a6e22e>mat2</span>(<span style=color:#a6e22e>cos</span>(_angle), <span style=color:#f92672>-</span><span style=color:#a6e22e>sin</span>(_angle),
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sin</span>(_angle), <span style=color:#a6e22e>cos</span>(_angle)) <span style=color:#f92672>*</span> _st;
</span></span><span style=display:flex><span>  _st <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> _st;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vec2 <span style=color:#a6e22e>tile</span> (vec2 _st, <span style=color:#66d9ef>float</span> _zoom) {
</span></span><span style=display:flex><span>  _st <span style=color:#f92672>*=</span> _zoom;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fract</span>(_st);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vec2 <span style=color:#a6e22e>rotateTilePattern</span>(vec2 _st) {
</span></span><span style=display:flex><span>  _st <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2.0</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>  index <span style=color:#f92672>+=</span> <span style=color:#a6e22e>step</span>(<span style=color:#ae81ff>1.</span>, <span style=color:#a6e22e>mod</span>(_st.x,<span style=color:#ae81ff>2.0</span>));
</span></span><span style=display:flex><span>  index <span style=color:#f92672>+=</span> <span style=color:#a6e22e>step</span>(<span style=color:#ae81ff>1.</span>, <span style=color:#a6e22e>mod</span>(_st.y,<span style=color:#ae81ff>2.0</span>))<span style=color:#f92672>*</span><span style=color:#ae81ff>2.0</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  _st <span style=color:#f92672>=</span> <span style=color:#a6e22e>fract</span>(_st);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(index <span style=color:#f92672>==</span> <span style=color:#ae81ff>1.0</span>){
</span></span><span style=display:flex><span>    _st <span style=color:#f92672>=</span> <span style=color:#a6e22e>rotate2D</span>(_st,PI<span style=color:#f92672>*</span><span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(index <span style=color:#f92672>==</span> <span style=color:#ae81ff>2.0</span>){
</span></span><span style=display:flex><span>    _st <span style=color:#f92672>=</span> <span style=color:#a6e22e>rotate2D</span>(_st,PI<span style=color:#f92672>*-</span><span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(index <span style=color:#f92672>==</span> <span style=color:#ae81ff>3.0</span>){
</span></span><span style=display:flex><span>    _st <span style=color:#f92672>=</span> <span style=color:#a6e22e>rotate2D</span>(_st,PI);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> _st;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><ul><li><p>Common in shader1.frag and shader2.frag</p><p>The uniform vec2 u_resolution; line declares a uniform variable u_resolution of type vec2 that represents the resolution (width and height) of the canvas or viewport.</p><p>The uniform float u_zoom; line declares a uniform variable u_zoom of type float that represents the zoom level.</p><p>The rotate2D() function takes a 2D vector _st and an angle _angle and rotates the vector around the origin (0.5, 0.5) using a 2D rotation matrix. The rotated vector is then shifted back to its original position before returning it.</p><p>The tile() function scales the input vector _st by _zoom and returns the fractional part of the scaled vector. This function is used to create a tiling effect based on the zoom level.</p><p>The rotateTilePattern() function takes an input vector _st and performs a rotation on it based on a tile pattern. The function first scales the input vector by 2.0, and then calculates an index value based on the modulo operation (mod()) on the x and y coordinates of the scaled vector. The index value determines the type of rotation to apply. If the index is 1, the vector is rotated by 90 degrees; if the index is 2, the vector is rotated by -90 degrees; if the index is 3, the vector is rotated by 180 degrees. Finally, the function returns the rotated vector.</p></li></ul><p><details open><summary>main() in shader1.frag</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span> (<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  vec2 st <span style=color:#f92672>=</span> gl_FragCoord.xy<span style=color:#f92672>/</span>u_resolution.xy;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  st <span style=color:#f92672>=</span> <span style=color:#a6e22e>tile</span>(st, u_zoom);
</span></span><span style=display:flex><span>  st <span style=color:#f92672>=</span> <span style=color:#a6e22e>rotateTilePattern</span>(st);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  st.x <span style=color:#f92672>*=</span> u_resolution.x<span style=color:#f92672>/</span>u_resolution.y;
</span></span><span style=display:flex><span>  vec3 color <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec3</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  st <span style=color:#f92672>=</span> st <span style=color:#f92672>*</span><span style=color:#ae81ff>2.</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1.</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  d <span style=color:#f92672>=</span> <span style=color:#a6e22e>length</span>( <span style=color:#a6e22e>abs</span>(st)<span style=color:#f92672>-</span><span style=color:#ae81ff>.3</span> );
</span></span><span style=display:flex><span>  d <span style=color:#f92672>=</span> <span style=color:#a6e22e>length</span>( <span style=color:#a6e22e>min</span>(<span style=color:#a6e22e>abs</span>(st)<span style=color:#f92672>-</span><span style=color:#ae81ff>.3</span>,<span style=color:#ae81ff>0.</span>) );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  gl_FragColor <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec4</span>(<span style=color:#a6e22e>vec3</span>(<span style=color:#a6e22e>fract</span>(d<span style=color:#f92672>*</span><span style=color:#ae81ff>10.0</span>)),<span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><details open><summary>main() in shader2.frag</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span> (<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  vec2 st <span style=color:#f92672>=</span> gl_FragCoord.xy<span style=color:#f92672>/</span>u_resolution.xy;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  st <span style=color:#f92672>=</span> <span style=color:#a6e22e>tile</span>(st, u_zoom);
</span></span><span style=display:flex><span>  st <span style=color:#f92672>=</span> <span style=color:#a6e22e>rotateTilePattern</span>(st);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  vec3 color <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec3</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  vec2 pos <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec2</span>(<span style=color:#ae81ff>0.5</span>)<span style=color:#f92672>-</span>st;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> r <span style=color:#f92672>=</span> <span style=color:#a6e22e>length</span>(pos)<span style=color:#f92672>*</span><span style=color:#ae81ff>2.0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> a <span style=color:#f92672>=</span> <span style=color:#a6e22e>atan</span>(pos.y,pos.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> f <span style=color:#f92672>=</span> <span style=color:#a6e22e>cos</span>(a<span style=color:#f92672>*</span><span style=color:#ae81ff>3.</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  color <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec3</span>( <span style=color:#ae81ff>1.</span><span style=color:#f92672>-</span><span style=color:#a6e22e>smoothstep</span>(f,f<span style=color:#f92672>+</span><span style=color:#ae81ff>0.02</span>,r) );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  gl_FragColor <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec4</span>(color,<span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details></p><ul><li><p>main() in shader1.frag</p><p>Overall, this fragment shader code generates a visual effect by creating a tiled pattern that rotates based on the specified zoom level, and applies a distance-based color effect around a threshold. The resulting color is then assigned to each fragment to produce the final rendered image.</p></li><li><p>main() in shader2.frag</p><p>Overall, this fragment shader code generates a visual effect by creating a tiled pattern that rotates based on a specified zoom level. It calculates the distance and angle from the center of the fragment to create a color value using the smoothstep function. The resulting color is then assigned to each fragment to produce the final rendered image.<br></br><strong>DRAG AND ZOOM!</strong></p><p><iframe id=procedural_texturing_toro style=width:570px;height:430px srcdoc="
            <!DOCTYPE html>
            <html>
              <head>
                <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
                <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
                 <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
                
                
                
                
                <script src=/showcase/sketches/procedural_texturing_toro.js></script>
              </head>
              <body>
              </body>
            </html>
          "></iframe><br></br><iframe id=procedural_texturing_box style=width:570px;height:430px srcdoc="
            <!DOCTYPE html>
            <html>
              <head>
                <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
                <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
                 <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
                
                
                
                
                <script src=/showcase/sketches/procedural_texturing_box.js></script>
              </head>
              <body>
              </body>
            </html>
          "></iframe></p></li></ul><h2 id=3-conclusions--future-work>3. Conclusions & future work
<a class=anchor href=#3-conclusions--future-work>#</a></h2><p>Based on the background given and the results of the code, some conclusions can be mentioned:</p><ul><li>Procedural texturing can be used to map a texture into a 3D figure.</li><li>A p5.Graphics object allows to create a graphics buffer object, acting as another canva.</li><li>Shaders are useful to create different patterns that can be used as textures, this patterns can be static or change when necessary.</li></ul><p>In this exercise, very simple examples of procedural texturing were shown. With this first steps, way more complex and creative work could be done in the future, such as very realistic textures for video-games or movies, more dinamic textures that can change with interaction of the user, automatic generation of textures depending on the 3D objects using AI, and more.</p><h2 id=references>References
<a class=anchor href=#references>#</a></h2><ul><li>The Book of Shaders: Patterns. (n.d.). Book of Shaders. Retrieved June 16, 2023, from <a href=https://thebookofshaders.com/09/>https://thebookofshaders.com/09/</a></li><li>Larsson, M., Ijiri, T., Yoshida, H., Huber, J. A. J. . 1989, Fredriksson, M. 1984, Broman, O., & Igarashi, T. (2022). Procedural texturing of solid wood with knots. ACM Transactions on Graphics, 41(4). <a href=https://doi-org.ezproxy.unal.edu.co/10.1145/3528223.3530081>https://doi-org.ezproxy.unal.edu.co/10.1145/3528223.3530081</a></li><li>Procedural Texturing. (2023, May 9). Visual Computing. Retrieved June 16, 2023, from <a href=https://visualcomputing.github.io/docs/shaders/procedural_texturing/>https://visualcomputing.github.io/docs/shaders/procedural_texturing/</a></li><li>Framebuffer. (n.d.). Wikipedia. Retrieved June 16, 2023, from <a href=https://en.wikipedia.org/wiki/Framebuffer>https://en.wikipedia.org/wiki/Framebuffer</a></li><li>Simulating clouds with procedural texturing techniques using the GPU. (2012).</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/29a079f70a161bea2e0cbcab3ed314fb749e415c title='Last modified by Daniel991104 | June 19, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 19, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#procedural-texturing>Procedural Texturing</a><ul><li><a href=#1-introduction--background>1. Introduction & Background</a></li><li><a href=#2-code--results>2. Code & results</a></li><li><a href=#3-conclusions--future-work>3. Conclusions & future work</a></li><li><a href=#references>References</a></li></ul></li></ul></nav></div></aside></main></body></html>