**3D Terrain Generation With Perlin Noise**

1. Introduction

In this academic report we are going to develop a 3D Terrain Generator that helps people who are cartographers digitizing representative maps of the world, artists or designers investing their own works, or videogame developers in creating, producing, and generating the necessary maps for the proper development of the video game.

To solve this problem, cartographers, artists, designers and developers use Perlin Noise due its ability to produce more natural-looking patterns of noise and its ability to create complex and varied patterns of noise that looked more natural and organic than previous algorithms.

Since its invention, Perlin noise has been extended and modified in various ways to suit different applications. For example, Simplex noise is a variant of Perlin noise that is faster to compute and has a more isotropic property, which means that it is more suitable for applications such as terrain generation.

2. Literature Review/Background

Perlin noise has wide applications in computer graphics, simulations, and other forms of procedural generation. Here are some concrete examples:

- Texture:

Perlin noise is often used to generate procedural textures for his 3D models in video games and animations. Create a variety of organic and natural textures such as clouds, water, and rocks.

- Terrain generation:

Perlin noise is used to create realistic terrain for video games, virtual environments, and simulations. By combining layers of noise, you can create complex and varied landscapes that look natural. animation:

Perlin noise is used to create animation effects in video games, movies, and other forms of digital media. For example, it can be used to simulate the movement of water or fire, or to create the flickering effect of a candle flame.

- Procedural modeling:

Perlin noise can be used to procedurally generate 3D models. By using noise to control vertex placement and shape, you can create organic, irregular shapes such as trees and rocks.

- Data visualization:

Perlin noise allows you to visualize your data in a more intuitive and natural way. For example, you can create heat maps or visualize particle distribution in fluid simulations.

- Sound generation:

Perlin noise can be used to create random sound effects like wind or water. By using noise to control the frequency and amplitude of sound waves, you can create natural and dynamic effects.

3. Methods Variables

<div>
<p style = 'text-align:center;'>
<img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhMkchc_oJVBt290LQpM0wjQR-Jgv4qrTcA3JWrt_i5jE30Lc3jFy3B6V4e3yakk63JuiYG5enGPg_R9oMiL0OU6ubHJxlgbneqInE-JB4t1vGnaKnlLg4DwiCKY1khHsrMlJv7skiTh0IZHX__BIuHC_kq9sFDZbvfUpgTun3v_kqMB5CMS2sB8Y7i/w623-h181/Aspose.Words.554c5bf7-97c8-4367-91fa-d5a01166ebe4.001.png" alt="variables" width = 100%>
</p>
</div>

We define a list called 'terrainValues' to store the different values generated by Perlin Noise for the map's development.

On the other hand, we define three optional variables in case of making a constant map: the variable called 'tam' determines the size of the map, the variable called 'mul' determines the variation of the map and the variable called 'noisy' determines the sound of the map.

function setup ()

<div>
<p style = 'text-align:center;'>
<img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiyRclJeoJ6cXlV6PiWL1ClTlTv8jGj2PodG4EKxQk-2iHBzbirvZTNhOUwa2G48du9_bJMos9tSXk6ksMZGOrc3Wv3Mi-cDshNwZ91c-frAgRM8LsaqOsNRemP7BodNgA0jpRXCKXavHtWoPCLUI0jCiIoKi_6N_xl62z3Vtl7fKzL4RGswNsqnZIk/w623-h967/Aspose.Words.554c5bf7-97c8-4367-91fa-d5a01166ebe4.002.png" alt="setup" width=100%>
</p>
</div>

In the “setup()” function we create a 800x800 pixels canva using “createCanvas()”. We also create 6 sliders: 'tam\_slider' controls the size of the map with a range from 0 to 80 and a variation of 10, 'mul\_slider' controls the modification limits of the map with a range from 0 to 150 and a variation of 10, 'noisy\_slider' controls the Perlin Noise generation of the map with a range from 0 to 1and a variation of 0.1, 'rotateX\_slider' controls the size of the map with a range from -90 to 90 and a variation of 10, 'rotateY\_slider' controls the size of the map with a range from -90 to 90 and a variation of 10, 'rotateZ\_slider' controls the size of the map with a range from -90 to 90 and a variation of 10.

function draw ()

<div>
<p style = 'text-align:center;'>
<img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjD9j4_EEipAZCkmmrYXmfkFiF0itIbQbvgJ6kRwz7FxgRMwm69tIGP6TGD-2dHFBSNJIaGnw8TwTWvcnCM3a2fP9HaYLV4BlbU-TCyq3aXm9jgcNuJ6kS4wf_3ZC3qkKlttWJEc-lSPPq4SR90QHMVWuQaCND1KsDnpdEMlwX7wZKuHPTF4wG-wRWM/w622-h738/Aspose.Words.554c5bf7-97c8-4367-91fa-d5a01166ebe4.003.png" alt="draw" width=100%>
</p>
</div>

In the “draw()” function we define angleMode in degrees for practicality reasons, background as black color, and stroke as white color. We define

6 variables: the variable called 'X' rotate the map on the X axis, the variable called 'Y' rotate the map on the Yaxis and the variable called 'Z' rotate the map on the Z axis, the variable called 'tam' controls the size of the map, the variable called 'mul' controls the modification limits of the map and the variable called 'noisy' controls the Perlin Noise generation of the map. Then we map Perlin Noise into 'terrainValues' list, apply triangle\_strip shape to the vertices, apply the triangle shape to the set of vertices, apply different colors according to the height of the vertices, and load the Perlin Noise data stored in the 'terrainValues' list to each pair of connected vertices.

4. Results

<div>
<p style = 'text-align:center;'>
<img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiFRQDR1L8jaFDNp2LLmwC7HlbCoWjSTor5CoUncsrzByVVsIhXZUZwe6F2lzxPLVIo0kWVwUiXuCARywNRW_iUdS-Tn8QZMi0rzqQysRimIolXDL54ShczDA_etGiSetjYon30wXVOT2bRgd6RRlapNxsMchPTAdqCwkCNyBsTFHguGr7it8ggKqJI/w616-h612/Aspose.Words.554c5bf7-97c8-4367-91fa-d5a01166ebe4.004.png" alt="results" width=100%>
</p>
</div>

<div>
<p style = 'text-align:center;'>
<img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhT5WwX-zcu-aCxaM8WBC179C16gDQHxWzUl0JAv4JoRHT2EUKPmN-BLywgHYUTASPRYYEq_OjpBB-Y0a9m1Ozk0-iD9qEw2e46tzNRGi-pptqgdEF5hD6LEdnNKzMA2FVxfk9g1VeTEQlsNV6p14fv6XO0XIPUbZtrnP_pcHV-UOHa8aBIT9im_6xi/w613-h608/Aspose.Words.554c5bf7-97c8-4367-91fa-d5a01166ebe4.005.png" alt="results" width=100%>
</p>
</div>

<div>
<p style = 'text-align:center;'>
<img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiH989lStXG37g8MhqalbP66LNVMuCK1yxCmHwRc48HtrkHn0G7TgQgKCTBKy-mKeSJxkr6IWfMKBUQKwps1aJJz0rj3gr1KkRPxb3graAz-RuOJQ0XM9k5VpOqUaTWTCVmM0uivhwidL-piGuuUp85LUrB7BqOLcU5bk_Uth-B3hgRrGwqv6ltdqm0/w615-h611/Aspose.Words.554c5bf7-97c8-4367-91fa-d5a01166ebe4.006.png" alt="results" width=100%>
</p>
</div>

5. Discussion

Perlin noise is a sort of gradient noise that is used in computer graphics, simulation, and other procedural generation methods. It is named after its inventor, Ken Perlin. It is a random function that produces a pattern of numbers that changes gradually across a specified space.

Perlin noise works by interpolating between random gradient vectors at different points in space. These vectors are smoothed out and combined to create a continuous pattern of values that appear to flow smoothly and naturally, with no discernible repetition.

One of the main advantages of using Perlin noise for terrain generation is its ability to produce fractal-like patterns, which means that the same pattern repeats at different scales. This property allows for the creation of terrain that appears to have a high level of detail and complexity, even when viewed from a distance.

Another advantage of using Perlin noise is its ability to create terrain that is responsive to different parameters, such as slope, altitude, and erosion. This makes it possible to create terrain that is tailored to specific environments, such as mountains, deserts, or forests.

The resulting pattern of values can be used for a variety of purposes, such as generating realistic textures, creating natural-looking landscapes, simulating the behavior of fluids, or creating dynamic animations.

Perlin noise has been widely used in video games, computer-generated imagery, and other forms of digital media to add depth, complexity, and realism to virtual environments. Its ability to generate complex and varied patterns of values has made it a popular tool for artists, designers, and programmers alike.

6. Conclusion

In conclusion, 3D terrain generation using Perlin noise has become a popular and effective technique for creating realistic and varied landscapes in video games, virtual environments, and simulations. By combining multiple layers of noise with different frequencies and amplitudes, it is possible to create complex and varied terrain that appears natural and organic.

Overall, 3D terrain generation using Perlin noise is a powerful tool that has become an essential part of the modern video game and simulation industry. With continued advances in computer hardware and software, it is likely that this technique will become even more widespread and effective in the future.


{{< p5-widget autoplay=true height="400" width="400" ver="1.5.0" >}}
var terrainValues = [];
function setup() { 
  createCanvas(800, 800, WEBGL);

  tam_slider = createSlider(0, 80, 80, 10);
  tam_slider.position(10, 10);
  tam_slider.style('width', '80px');
  tam_slider.style('height', '80px');
  
  mul_slider = createSlider(0, 150, 150, 10);
  mul_slider.position(110, 10);
  mul_slider.style('width', '80px');
  mul_slider.style('height', '80px');
  
  noisy_slider = createSlider(0, 1, 0, 0.1);
  noisy_slider.position(210, 10);
  noisy_slider.style('width', '80px');
  noisy_slider.style('height', '80px');
  
  rotateX_slider = createSlider(-90, 90, 50, 10);
  rotateX_slider.position(10, 60);
  rotateX_slider.style('width', '80px');
  rotateX_slider.style('height', '80px');
  
  rotateY_slider = createSlider(-90, 90, 0, 10);
  rotateY_slider.position(10, 110);
  rotateY_slider.style('width', '80px');
  rotateY_slider.style('height', '80px');
  
  rotateZ_slider = createSlider(-90, 90, 0, 10);
  rotateZ_slider.position(10, 160);
  rotateZ_slider.style('width', '80px');
  rotateZ_slider.style('height', '80px');
  
}

function draw() { 
  angleMode(DEGREES); 
  background(0);
  stroke(128);
  let X = rotateX_slider.value();
  let Y = rotateY_slider.value();
  let Z = rotateZ_slider.value();
  rotateX(X);
  rotateY(Y);
  rotateZ(Z);
  translate(-width/2, -height/2)
  
  let tam = tam_slider.value();
  let mul = mul_slider.value();
  let noisy = noisy_slider.value();
    for (var yy=0; yy<tam; yy++){
    // tamaño mapa eje y
      terrainValues.push([]);
      for (var xx=0; xx<tam; xx++){
      // tamaño mapa eje x
      terrainValues[yy][xx] = map(noise(xx*noisy,yy*noisy), 0, 1, -mul, mul);
    }
  }

  
  for (var y=0; y<tam; y++){
    // tamaño mapa eje y
    beginShape (TRIANGLE_STRIP) 
    for (var x=0; x<tam; x++){
      // tamaño mapa eje x
      if (terrainValues[y][y] < -50){
        fill('white');
      }else if (terrainValues[y][y] < 0){
        fill('rgb(128,85,128)');
      }else if (terrainValues[y][y] < 50){
        fill('rgb(128,170,128)');
      }else{
        fill('rgb(128,0,128)');
      }
      vertex (x*10, y*10, terrainValues[y][y]); 
      // tamaño triangulos
      vertex (x*10, (y+1)*10, terrainValues[y][x]);
      // tamaño diagonales
    } 
    endShape();
  }
}

{{< /p5-widget >}}
